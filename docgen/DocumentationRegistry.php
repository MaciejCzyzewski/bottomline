<?php

namespace __\DocGen;

use Exception;
use JsonSerializable;
use PhpParser\Comment;
use PhpParser\Node\Stmt;
use ReflectionFunction;

class DocumentationRegistry implements JsonSerializable
{
    /** @var array<string, int> */
    public array $namespaceCount;

    /** @var array<int, FunctionDocumentation> */
    public array $methods;

    public function __construct()
    {
        $this->namespaceCount = [];
        $this->methods = [];
    }

    public function registerDocumentationFromFile(string $filePath): bool
    {
        $fileName = basename($filePath);
        $namespace = basename(dirname($filePath));
        // If the file starts with an uppercase letter, then it's a class so let's not count it
        if (preg_match('/[A-Z]/', substr($fileName, 0, 1)) === 1) {
            return false;
        }
        if (!isset($this->namespaceCount[$namespace])) {
            $this->namespaceCount[$namespace] = 1;
        } else {
            $this->namespaceCount[$namespace]++;
        }
        include $filePath;
        $this->parsePhpSource($filePath, $fileName, $namespace);

        return true;
    }

    public function jsonSerialize(): mixed
    {
        return [
            '_readme' => [
                'This file is automatically generated by our phpDocGen.php and is',
                'a part of our auto-documentation process. If you see a mistake,',
                'please edit the documentation in the respective function files.',
            ],
            'methods' => $this->methods,
        ];
    }

    private function parsePhpSource(string $filePath, string $fileName, string $namespace): void
    {
        $parsedPhp = Parsers::$phpParser->parse(file_get_contents($filePath));
        /** @var Stmt\Namespace_|Stmt\Return_ $rootElement */
        $rootElement = array_shift($parsedPhp);
        switch ($rootElement->getType()) {
            case 'Stmt_Namespace':
                $nodes = $rootElement->stmts;
                foreach ($nodes as $node) {
                    if ($node->getType() !== 'Stmt_Function') {
                        continue;
                    }
                    $fxnName = $node->name->name;
                    $comments = $node->getAttribute('comments');
                    /** @var Comment $docBlock */
                    $docBlock = array_pop($comments);
                    $this->registerBottomlineFunction($fxnName, $docBlock, $namespace);
                }
                break;
            case 'Stmt_Return':
                $fxnName = pathinfo($fileName, PATHINFO_FILENAME);
                $comments = $rootElement->getAttribute('comments');
                /** @var Comment $docBlock */
                $docBlock = array_pop($comments);
                $this->registerBottomlineFunction($fxnName, $docBlock, null, $rootElement->expr->value, $namespace);
                break;
            default:
                break;
        }
    }

    /**
     * @param string      $functionName
     * @param Comment     $docBlock
     * @param string|null $actualNamespace The actual namespace declared via the PHP `namespace` keyword
     * @param string|null $fqfn            Fully-qualified function name
     * @param string|null $blNamespace     The fake namespace; i.e. the folder name this function is defined in
     */
    private function registerBottomlineFunction(string $functionName, Comment $docBlock, ?string $actualNamespace = null, ?string $fqfn = null, ?string $blNamespace = null)
    {
        try {
            // If function name starts with an underscore, it's a helper function not part of the API
            if ($functionName[0] === '_') {
                return;
            }
            if ($actualNamespace !== null) {
                $fullyQualifiedFunctionName = sprintf("%s\\%s", $actualNamespace, $functionName);
            } elseif ($fqfn !== null) {
                $fullyQualifiedFunctionName = $fqfn;
            } else {
                $fullyQualifiedFunctionName = $functionName;
            }

            $docBlock = Parsers::$docBlockParser->create($docBlock->getText());
            $isInternal = count($docBlock->getTagsByName('internal')) > 0;

            if ($isInternal) {
                return;
            }

            $functionDefinition = new ReflectionFunction($fullyQualifiedFunctionName);
            $this->methods[] = new FunctionDocumentation($functionDefinition, $docBlock, $functionName, $blNamespace);
        } catch (Exception $e) {
            printf("Exception message: %s\n", $e->getMessage());
            printf("  %s\n\n", $functionName);
        }
    }
}
